<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Brickpop</title>
  <style>
    :root {
      --ink: #000;
      --paper: #fff;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--paper);
      color: var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    .wrap {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 12px;
      box-sizing: border-box;
    }

    .shell {
      width: min(960px, 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .hudbar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .btn {
      font: inherit;
      font-size: 12px;
      line-height: 1;
      letter-spacing: 0.02em;
      border: 1px solid var(--ink);
      background: transparent;
      padding: 6px 10px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }

    .btn:focus-visible {
      outline: 1px solid var(--ink);
      outline-offset: 2px;
    }

    @media (max-width: 520px) {
      .hudbar { flex-wrap: wrap; justify-content: center; }
    }

    /* Fullscreen container: keep 3:2 stage, fit to viewport */
    .shell:fullscreen {
      width: 100vw;
      height: 100vh;
      padding: 12px;
      box-sizing: border-box;
      background: var(--paper);
      display: grid;
      grid-template-rows: 1fr auto;
      justify-items: center;
      align-content: center;
      gap: 10px;
    }

    .shell:fullscreen .stage {
      width: min(calc(100vw - 24px), calc((100vh - 24px - 44px) * 1.5));
      max-width: 100%;
      aspect-ratio: 3 / 2;
    }

    .shell:fullscreen .hudbar {
      width: min(1100px, 100%);
    }

    .shell:fullscreen .overlayBox {
      max-width: 640px;
    }

    /* Pseudo fullscreen fallback (no browser UI removal, but fills viewport) */
    .shell.pseudoFS {
      position: fixed;
      inset: 0;
      z-index: 999999;
      padding: 12px;
      box-sizing: border-box;
      background: var(--paper);
      display: grid;
      grid-template-rows: 1fr auto;
      justify-items: center;
      align-content: center;
      gap: 10px;
    }

    .shell.pseudoFS .stage {
      width: min(calc(100vw - 24px), calc((100vh - 24px - 44px) * 1.5));
      max-width: 100%;
      aspect-ratio: 3 / 2;
    }

    .shell.pseudoFS .hudbar {
      width: min(1100px, 100%);
    }

    .shell.pseudoFS .overlayBox {
      max-width: 640px;
    }

    .stage {
      width: 100%;
      aspect-ratio: 3 / 2;
      border: 1px solid var(--ink);
      background: var(--paper);
      position: relative;
      user-select: none;
      -webkit-user-select: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .srOnly {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .scoreline {
      width: auto;
      flex: 1;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: max-content;
      align-items: baseline;
      column-gap: 6px;
      font-size: 12px;
      line-height: 1;
      letter-spacing: 0.02em;
      user-select: none;
      -webkit-user-select: none;
      font-variant-numeric: tabular-nums;
    }

    .scoreline dt,
    .scoreline dd {
      margin: 0;
      padding: 0;
      white-space: nowrap;
    }

    .scoreline dd {
      font-weight: 700;
      margin-right: 12px;
    }

    .scoreline dd:last-of-type {
      margin-right: 0;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      background: transparent;
      padding: 16px;
      box-sizing: border-box;
      text-align: center;
    }

    .overlay.hidden { display: none; }

    .overlayBox {
      border: 1px solid var(--ink);
      background: rgba(255,255,255,0.92);
      padding: 10px 12px;
      max-width: 520px;
    }

    .overlayTitle {
      font-size: 16px;
      line-height: 1.1;
      letter-spacing: 0.14em;
      font-weight: 600;
      margin-bottom: 6px;
    }

    #overlayText {
      font-size: 12px;
      line-height: 1.25;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 600;
    }

    .help {
      margin-top: 6px;
      font-size: 11px;
      opacity: 0.75;
      line-height: 1.25;
    }

    @media (prefers-reduced-motion: reduce) {
      * { scroll-behavior: auto !important; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="shell" id="shell">
      <div class="stage" id="stage">
        <canvas id="game" aria-label="Brickpop game"></canvas>

        <div class="overlay hidden" id="overlay" role="status" aria-live="polite">
          <div class="overlayBox">
            <div class="overlayTitle" id="overlayTitle">BRICKPOP</div>
            <div id="overlayText">PRESS SPACE / TAP TO START. IT CHANGES NOTHING.</div>
            <div class="help" id="overlayHelp">←/→ or drag • Space/tap: launch / pause • R: restart</div>
          </div>
        </div>
      </div>

      <div class="hudbar">
        <dl class="scoreline" aria-label="Game status">
          <dt id="labelScore">SCORE</dt>
          <dd><span id="score">0</span></dd>

          <dt id="labelBest">BEST</dt>
          <dd><span id="best">0</span></dd>

          <dt id="labelLives">LIVES</dt>
          <dd><span id="lives">3</span></dd>

          <dt id="labelLevel">LEVEL</dt>
          <dd><span id="level">1</span></dd>
        </dl>
        <div id="srStatus" class="srOnly" aria-live="polite" aria-atomic="true"></div>
        <button class="btn" id="fsBtn" type="button" aria-label="Toggle fullscreen" aria-pressed="false">FULLSCREEN</button>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.lineJoin = 'miter';
ctx.lineCap = 'butt';

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const overlayTitleEl = document.getElementById('overlayTitle');
const overlayHelpEl = document.getElementById('overlayHelp');
const labelScoreEl = document.getElementById('labelScore');
const labelBestEl = document.getElementById('labelBest');
const labelLivesEl = document.getElementById('labelLives');
const labelLevelEl = document.getElementById('labelLevel');
const shell = document.getElementById('shell');
const fsBtn = document.getElementById('fsBtn');
const srStatusEl = document.getElementById('srStatus');

// --- All copy in one place ---
const TEXT = {
  pageTitle: 'Brickpop',
  gameName: 'BRICKPOP',
  labels: {
    score: 'SCORE',
    best: 'BEST',
    lives: 'LIVES',
    level: 'LEVEL',
  },
  help: '←/→ or drag • Space/tap: launch / pause • R: restart',
  overlay: {
    start: 'PRESS SPACE / TAP TO START. IT CHANGES NOTHING.',
    startAgain: 'Space/tap to start. Again.',
    paused: 'Paused — Space/tap to continue pretending.',
    lifeLost: 'Life lost — Space/tap. Carry on.',
    gameOver: 'Game over — Space/tap or R. Reset.',
    level: (n) => `Level ${n} — Space/tap. Same game.`,
    rotate: 'ROTATE TO LANDSCAPE FOR FULL SCREEN.',
  },
};

// Rules (kept here as editable copy; not rendered in-game)
const RULES = {
  objective: 'Clear the bricks. Advance a number. Repeat.',
  controls: [
    'Desktop: ←/→ moves the paddle.',
    'Mobile/pointer: drag to move.',
    'Space/tap: launch if waiting; otherwise pause/resume.',
    'R: restart.',
    'P or Esc: pause/resume.',
  ],
  scoring: [
    'Hit brick (HP remains): +50',
    'Destroy brick: +100',
  ],
  lives: [
    'Start with 3 lives.',
    'Ball drops below the bottom edge: lose 1 life; ball resets.',
    'At 0 lives: game over.',
  ],
  levels: [
    'Clear all bricks: next level.',
    'Up to two top rows take 2 hits (HP = 2).',
    'Paddle shrinks each level (to a minimum width).',
  ],
};

function applyStaticText() {
  document.title = TEXT.pageTitle;
  overlayTitleEl.textContent = TEXT.gameName;
  overlayHelpEl.textContent = TEXT.help;
  labelScoreEl.textContent = TEXT.labels.score;
  labelBestEl.textContent = TEXT.labels.best;
  labelLivesEl.textContent = TEXT.labels.lives;
  labelLevelEl.textContent = TEXT.labels.level;
}
applyStaticText();

// --- Overlay helpers ---
function announceStatus(msg) {
  if (!srStatusEl) return;
  // Ensures repeated messages are announced.
  srStatusEl.textContent = '';
  requestAnimationFrame(() => {
    srStatusEl.textContent = msg;
  });
}

function showOverlay(msg) {
  overlayText.textContent = msg;
  overlay.classList.remove('hidden');
  announceStatus(msg);
}

function hideOverlay() {
  overlay.classList.add('hidden');
}

// --- Fullscreen helpers ---
const IS_COARSE = window.matchMedia?.('(pointer: coarse)').matches ?? false;
let rotateHold = false;
let rotateHoldPrevPaused = false;

function setPageScrollLocked(locked) {
  document.documentElement.style.overflow = locked ? 'hidden' : '';
  document.body.style.overflow = locked ? 'hidden' : '';
  document.body.style.touchAction = locked ? 'none' : '';
}

function inNativeFullscreen() {
  return document.fullscreenElement === shell;
}

function inPseudoFullscreen() {
  return !!shell?.classList.contains('pseudoFS');
}

function inFullscreen() {
  return inNativeFullscreen() || inPseudoFullscreen();
}

function updateFsUI() {
  if (!fsBtn) return;
  const on = inFullscreen();
  fsBtn.textContent = on ? 'EXIT' : 'FULLSCREEN';
  fsBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
}

function isPortrait() {
  return window.innerHeight > window.innerWidth;
}

function checkRotateHold(leaving = false) {
  if (leaving || !inFullscreen() || !IS_COARSE) {
    rotateHold = false;
    return;
  }

  if (isPortrait()) {
    if (!rotateHold) {
      rotateHold = true;
      rotateHoldPrevPaused = paused;
      paused = true;
      showOverlay(TEXT.overlay.rotate);
    }
    return;
  }

  if (rotateHold) {
    rotateHold = false;
    if (!awaitingLaunch && !gameOver && !rotateHoldPrevPaused) {
      paused = false;
      hideOverlay();
    }
  }
}

async function enterFullscreen() {
  // Try native fullscreen first
  if (shell?.requestFullscreen && document.fullscreenEnabled) {
    try {
      await shell.requestFullscreen();
      try { await screen.orientation?.lock?.('landscape'); } catch {}
      updateFsUI();
      checkRotateHold();
      return;
    } catch {
      // fall through to pseudo fullscreen
    }
  }

  // Pseudo fullscreen fallback (useful for iOS / restrictive embeds)
  if (!shell) return;
  shell.classList.add('pseudoFS');
  setPageScrollLocked(true);
  updateFsUI();
  checkRotateHold();
}

async function exitFullscreen() {
  if (inNativeFullscreen()) {
    try { await document.exitFullscreen(); } catch {}
    try { screen.orientation?.unlock?.(); } catch {}
  }

  if (inPseudoFullscreen()) {
    shell.classList.remove('pseudoFS');
    setPageScrollLocked(false);
  }

  updateFsUI();
  checkRotateHold(true);
}

function toggleFullscreen() {
  if (inFullscreen()) exitFullscreen();
  else enterFullscreen();
}

fsBtn?.addEventListener('click', toggleFullscreen);
document.addEventListener('fullscreenchange', () => {
  updateFsUI();
  checkRotateHold();
});

window.addEventListener('resize', checkRotateHold);
window.addEventListener('orientationchange', checkRotateHold);

updateFsUI();

// --- World (logical) size ---
const W = 900;
const H = 600;
const INSET = 18;

const FRAME_STROKE = '#000000';
const MAX_BALL_SPEED = 900;
const HIT_SPEEDUP_DESTROY = 1.006;
const HIT_SPEEDUP_DENT = 1.003;

const STORAGE_KEY_BEST = 'brickpop_best_v1';

function loadBestScore() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY_BEST);
    const n = raw ? Number(raw) : 0;
    return Number.isFinite(n) && n > 0 ? Math.floor(n) : 0;
  } catch {
    return 0;
  }
}

function saveBestScore(value) {
  try {
    localStorage.setItem(STORAGE_KEY_BEST, String(Math.floor(value)));
  } catch {}
}

let best = loadBestScore();
bestEl.textContent = String(best);

function setupCanvas() {
  const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  canvas.width = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.translate(0.5, 0.5);
}
setupCanvas();
window.addEventListener('resize', setupCanvas);

// --- Game state ---
let score = 0;
let lives = 3;
let level = 1;
let paused = true;
let awaitingLaunch = true;
let gameOver = false;

const paddle = {
  x: (W - 140) / 2,
  y: H - INSET - 30,
  w: 140,
  h: 14,
  vx: 0,
  speed: 760,
};

const ball = {
  x: W / 2,
  y: paddle.y - 9,
  vx: 0,
  vy: 0,
  r: 7,
  stuck: true,
};

let bricks = [];

// --- Hit FX (wireframe-safe) ---
const REDUCE_MOTION = window.matchMedia?.('(prefers-reduced-motion: reduce)').matches ?? false;
const effects = []; // {type:'burst'|'box', x,y,w,h,t,dur,strong}

function addEffect(e) {
  if (REDUCE_MOTION) return;
  effects.push(e);
  if (effects.length > 60) effects.splice(0, effects.length - 60);
}

function burst(x, y, strong) {
  addEffect({ type: 'burst', x, y, t: 0, dur: strong ? 0.16 : 0.12, strong: !!strong });
}

function box(x, y, w, h, strong) {
  addEffect({ type: 'box', x, y, w, h, t: 0, dur: strong ? 0.18 : 0.14, strong: !!strong });
}

function tickEffects(dt) {
  for (let i = effects.length - 1; i >= 0; i--) {
    const e = effects[i];
    e.t += dt;
    if (e.t >= e.dur) effects.splice(i, 1);
  }
}

function drawEffects() {
  if (!effects.length) return;

  ctx.save();
  ctx.strokeStyle = FRAME_STROKE;
  ctx.lineWidth = 1;

  for (const e of effects) {
    const p = e.t / e.dur;
    const fade = 1 - p;
    ctx.globalAlpha = 0.55 * fade;

    if (e.type === 'box') {
      const pad = (e.strong ? 6 : 4) * p;
      ctx.strokeRect(e.x - pad, e.y - pad, e.w + pad * 2, e.h + pad * 2);
      continue;
    }

    const rays = e.strong ? 10 : 8;
    const r = (e.strong ? 18 : 12) * p + 2;
    for (let i = 0; i < rays; i++) {
      const a = (i / rays) * Math.PI * 2;
      const x1 = e.x + Math.cos(a) * (r * 0.45);
      const y1 = e.y + Math.sin(a) * (r * 0.45);
      const x2 = e.x + Math.cos(a) * r;
      const y2 = e.y + Math.sin(a) * r;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
  }

  ctx.restore();
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

let lastAnnounced = {
  lives: null,
  level: null,
  best: null,
};

function setHUD() {
  scoreEl.textContent = String(score);
  livesEl.textContent = String(lives);
  levelEl.textContent = String(level);

  if (score > best) {
    best = score;
    bestEl.textContent = String(best);
    saveBestScore(best);

    if (lastAnnounced.best !== best) {
      lastAnnounced.best = best;
      announceStatus(`New best: ${best}`);
    }
  }

  // Avoid spamming announcements; only key state changes.
  if (lastAnnounced.lives !== lives) {
    lastAnnounced.lives = lives;
    if (!gameOver) announceStatus(`Lives: ${lives}`);
  }

  if (lastAnnounced.level !== level) {
    lastAnnounced.level = level;
    announceStatus(`Level: ${level}`);
  }
}

function setPaddleForLevel() {
  paddle.w = clamp(140 - (level - 1) * 8, 96, 140);
  paddle.speed = 760 + (level - 1) * 22;
  paddle.x = clamp(paddle.x, INSET, W - INSET - paddle.w);
}

function resetBall(message) {
  ball.stuck = true;
  ball.vx = 0;
  ball.vy = 0;
  awaitingLaunch = true;
  paused = true;
  ball.x = paddle.x + paddle.w / 2;
  ball.y = paddle.y - ball.r - 2;
  showOverlay(message);
}

function restartGame() {
  score = 0;
  lives = 3;
  level = 1;
  gameOver = false;
  setPaddleForLevel();
  makeBricks();
  setHUD();
  resetBall(TEXT.overlay.startAgain);
}

function baseBallSpeed() {
  return 420 + (level - 1) * 34;
}

function ballSpeed() {
  return Math.hypot(ball.vx, ball.vy);
}

function rescaleBallTo(speed) {
  const sp = ballSpeed();
  if (sp < 0.0001) return;
  const k = speed / sp;
  ball.vx *= k;
  ball.vy *= k;
}

function clampBallSpeed(minSpeed = baseBallSpeed()) {
  const sp = ballSpeed();
  const target = clamp(sp, minSpeed, MAX_BALL_SPEED);
  if (Math.abs(target - sp) > 0.001) rescaleBallTo(target);
}

function nudgeAwayFromBoringAngles() {
  const minAbsVx = 55;
  const minAbsVy = 120;

  let vx = ball.vx;
  let vy = ball.vy;
  if (Math.abs(vx) < minAbsVx) vx = minAbsVx * (vx >= 0 ? 1 : -1);
  if (Math.abs(vy) < minAbsVy) vy = minAbsVy * (vy >= 0 ? 1 : -1);

  const target = clamp(ballSpeed(), baseBallSpeed(), MAX_BALL_SPEED);
  const sp2 = Math.hypot(vx, vy);
  if (sp2 < 0.0001) return;
  const k = target / sp2;
  ball.vx = vx * k;
  ball.vy = vy * k;
}

let lastServeDir = 1;

function launchBall() {
  if (!awaitingLaunch) return;
  awaitingLaunch = false;
  paused = false;
  hideOverlay();

  let dir = 0;
  if (Math.abs(paddle.vx) > 40) dir = Math.sign(paddle.vx);
  if (!dir) dir = lastServeDir || (Math.random() > 0.5 ? 1 : -1);
  lastServeDir = dir;

  const min = 30 * Math.PI / 180;
  const max = 65 * Math.PI / 180;
  const ang = (Math.random() * (max - min) + min) * dir;
  const s = baseBallSpeed();
  ball.vx = Math.sin(ang) * s;
  ball.vy = -Math.cos(ang) * s;
  ball.stuck = false;
}

function togglePause() {
  if (awaitingLaunch) return;
  paused = !paused;
  if (paused) showOverlay(TEXT.overlay.paused);
  else hideOverlay();
}

function handleAction() {
  if (rotateHold) return;
  if (gameOver) {
    restartGame();
    return;
  }
  if (awaitingLaunch) {
    launchBall();
    return;
  }
  togglePause();
}

function makeBricks() {
  bricks = [];
  const rows = 5 + Math.min(2, level - 1); // 5..7
  const cols = 12;
  const bw = 60;
  const bh = 20;
  const gap = 8;

  const gridW = cols * bw + (cols - 1) * gap;
  const startX = Math.round((W - gridW) / 2);
  const startY = 60;

  const toughRows = Math.min(2, Math.floor(level / 2));

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const hp = 1 + (r < toughRows ? 1 : 0);
      bricks.push({
        x: startX + c * (bw + gap),
        y: startY + r * (bh + gap),
        w: bw,
        h: bh,
        hp,
        alive: true,
      });
    }
  }
}

function aliveBricks() {
  let n = 0;
  for (const b of bricks) if (b.alive) n++;
  return n;
}

function loseLife() {
  lives -= 1;
  setHUD();

  if (lives <= 0) {
    gameOver = true;
    paused = true;
    awaitingLaunch = true;
    ball.stuck = true;
    ball.vx = 0;
    ball.vy = 0;
    showOverlay(TEXT.overlay.gameOver);
    return;
  }

  resetBall(TEXT.overlay.lifeLost);
}

function nextLevel() {
  level += 1;
  setPaddleForLevel();
  makeBricks();
  setHUD();
  resetBall(TEXT.overlay.level(level));
}

// --- Input ---
let left = false;
let right = false;
let pointerDown = false;
let pointerMoved = false;
let pointerStart = { x: 0, y: 0 };
let pointerLastTs = 0;

const POINTER_VX_MAX = 2200;

window.addEventListener('keydown', (e) => {
  if (e.code === 'ArrowLeft') left = true;
  if (e.code === 'ArrowRight') right = true;

  if (e.code === 'Space') {
    e.preventDefault?.();
    handleAction();
  }

  if (e.code === 'KeyP' || e.code === 'Escape') {
    e.preventDefault?.();
    togglePause();
  }

  if (e.code === 'KeyF') {
    e.preventDefault?.();
    toggleFullscreen();
  }

  if (e.code === 'KeyR') {
    e.preventDefault?.();
    restartGame();
  }
});

window.addEventListener('keyup', (e) => {
  if (e.code === 'ArrowLeft') left = false;
  if (e.code === 'ArrowRight') right = false;
});

function clientToWorld(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (W / rect.width);
  const y = (clientY - rect.top) * (H / rect.height);
  return { x, y };
}

canvas.addEventListener('pointerdown', (e) => {
  pointerDown = true;
  pointerMoved = false;
  const p = clientToWorld(e.clientX, e.clientY);
  pointerStart = { x: p.x, y: p.y };

      pointerLastTs = e.timeStamp ?? performance.now();

  const prevX = paddle.x;
  paddle.x = clamp(p.x - paddle.w / 2, INSET, W - INSET - paddle.w);
  paddle.vx = 0;

  if (awaitingLaunch) lastServeDir = (p.x < W / 2) ? -1 : 1;

  canvas.setPointerCapture?.(e.pointerId);
});

canvas.addEventListener('pointermove', (e) => {
  if (!pointerDown) return;
  const p = clientToWorld(e.clientX, e.clientY);
  const dx = p.x - pointerStart.x;
  const dy = p.y - pointerStart.y;
  if ((dx * dx + dy * dy) > (10 * 10)) pointerMoved = true;
  const ts = e.timeStamp ?? performance.now();
  const dt = Math.max(0.001, Math.min(0.05, (ts - (pointerLastTs || ts)) / 1000));
  pointerLastTs = ts;

  const prevX = paddle.x;
  paddle.x = clamp(p.x - paddle.w / 2, INSET, W - INSET - paddle.w);
  paddle.vx = clamp((paddle.x - prevX) / dt, -POINTER_VX_MAX, POINTER_VX_MAX);
});

function pointerUp() {
  if (!pointerDown) return;
  pointerDown = false;
  if (!pointerMoved) handleAction();
}

canvas.addEventListener('pointerup', pointerUp);
canvas.addEventListener('pointercancel', pointerUp);

function autoPause() {
  if (!paused && !awaitingLaunch && !gameOver) {
    paused = true;
    showOverlay(TEXT.overlay.paused);
  }
}

window.addEventListener('blur', autoPause);
document.addEventListener('visibilitychange', () => {
  if (document.hidden) autoPause();
});

// --- Collision helpers (swept point vs AABB) ---
function sweepPointAABB(px, py, dx, dy, rx, ry, rw, rh) {
  let tEntryX = -Infinity, tExitX = Infinity;
  let tEntryY = -Infinity, tExitY = Infinity;
  let nx = 0, ny = 0;

  if (dx === 0) {
    if (px < rx || px > rx + rw) return null;
  } else {
    const inv = 1 / dx;
    let t1 = (rx - px) * inv;
    let t2 = (rx + rw - px) * inv;
    if (t1 > t2) [t1, t2] = [t2, t1];
    tEntryX = t1;
    tExitX = t2;
  }

  if (dy === 0) {
    if (py < ry || py > ry + rh) return null;
  } else {
    const inv = 1 / dy;
    let t1 = (ry - py) * inv;
    let t2 = (ry + rh - py) * inv;
    if (t1 > t2) [t1, t2] = [t2, t1];
    tEntryY = t1;
    tExitY = t2;
  }

  const tEntry = Math.max(tEntryX, tEntryY);
  const tExit = Math.min(tExitX, tExitY);
  if (tEntry > tExit || tExit < 0 || tEntry > 1) return null;

  if (tEntryX > tEntryY) {
    nx = dx > 0 ? -1 : 1;
    return { t: tEntry, nx, ny: 0 };
  }

  ny = dy > 0 ? -1 : 1;
  return { t: tEntry, nx: 0, ny };
}

function earliestCollision(px, py, dx, dy) {
  const xMin = INSET + ball.r;
  const xMax = W - INSET - ball.r;
  const yMin = INSET + ball.r;

  let bestCol = { t: 1, nx: 0, ny: 0, type: 'none', ref: null };

  if (dx > 0) {
    const t = (xMax - px) / dx;
    if (t >= 0 && t < bestCol.t) bestCol = { t, nx: -1, ny: 0, type: 'wall', ref: null };
  } else if (dx < 0) {
    const t = (xMin - px) / dx;
    if (t >= 0 && t < bestCol.t) bestCol = { t, nx: 1, ny: 0, type: 'wall', ref: null };
  }

  if (dy < 0) {
    const t = (yMin - py) / dy;
    if (t >= 0 && t < bestCol.t) bestCol = { t, nx: 0, ny: 1, type: 'wall', ref: null };
  }

  {
    const hit = sweepPointAABB(
      px, py, dx, dy,
      paddle.x - ball.r,
      paddle.y - ball.r,
      paddle.w + ball.r * 2,
      paddle.h + ball.r * 2,
    );
    if (hit && hit.t >= 0 && hit.t < bestCol.t) {
      bestCol = { t: hit.t, nx: hit.nx, ny: hit.ny, type: 'paddle', ref: null };
    }
  }

  for (const b of bricks) {
    if (!b.alive) continue;
    const hit = sweepPointAABB(
      px, py, dx, dy,
      b.x - ball.r,
      b.y - ball.r,
      b.w + ball.r * 2,
      b.h + ball.r * 2,
    );
    if (hit && hit.t >= 0 && hit.t < bestCol.t) {
      bestCol = { t: hit.t, nx: hit.nx, ny: hit.ny, type: 'brick', ref: b };
    }
  }

  bestCol.t = clamp(bestCol.t, 0, 1);
  return bestCol;
}

function bounceOffPaddle() {
  if (ball.vy <= 0) return;

  const hit = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
  const clampedHit = clamp(hit, -1, 1);
  const maxAngle = 62 * Math.PI / 180;
  const angle = clampedHit * maxAngle;

  const speed = clamp(Math.max(baseBallSpeed(), ballSpeed()), baseBallSpeed(), MAX_BALL_SPEED);
  const spin = clamp(paddle.vx * 0.14, -150, 150);

  ball.vx = Math.sin(angle) * speed + spin;
  ball.vy = -Math.cos(angle) * speed;

  ball.y = paddle.y - ball.r - 0.5;

  clampBallSpeed();
  nudgeAwayFromBoringAngles();
}

function hitBrick(b, hx, hy) {
  if (!b.alive) return;

  const strong = b.hp <= 1;

  box(b.x, b.y, b.w, b.h, strong);
  burst(hx, hy, strong);

  b.hp -= 1;
  if (b.hp <= 0) {
    b.alive = false;
    score += 100;
    ball.vx *= HIT_SPEEDUP_DESTROY;
    ball.vy *= HIT_SPEEDUP_DESTROY;
  } else {
    score += 50;
    ball.vx *= HIT_SPEEDUP_DENT;
    ball.vy *= HIT_SPEEDUP_DENT;
  }

  setHUD();
  clampBallSpeed();
  nudgeAwayFromBoringAngles();
}

function moveBall(dt) {
  let remaining = dt;
  const maxBounces = 6;

  for (let i = 0; i < maxBounces && remaining > 0.000001; i++) {
    const px = ball.x;
    const py = ball.y;
    const dx = ball.vx * remaining;
    const dy = ball.vy * remaining;

    const col = earliestCollision(px, py, dx, dy);

    ball.x = px + dx * col.t;
    ball.y = py + dy * col.t;

    remaining *= (1 - col.t);

    if (col.type === 'none') break;

    let nx = col.nx;
    let ny = col.ny;

    // Paddle: if travelling downwards, ALWAYS treat as a paddle bounce.
    if (col.type === 'paddle' && ball.vy > 0) {
      bounceOffPaddle();
      nx = 0;
      ny = -1;
    } else {
      if (nx) ball.vx *= -1;
      if (ny) ball.vy *= -1;

      if (col.type === 'brick') hitBrick(col.ref, ball.x, ball.y);

      clampBallSpeed();
      nudgeAwayFromBoringAngles();
    }

    const nudge = 0.08;
    ball.x += nx * nudge;
    ball.y += ny * nudge;

    if (col.t < 0.00001) remaining = Math.max(0, remaining - 0.00001);
  }
}

// --- Simulation ---
function draw() {
  ctx.clearRect(-1, -1, W + 2, H + 2);

  ctx.strokeStyle = FRAME_STROKE;
  ctx.lineWidth = 1;

  ctx.strokeRect(INSET, INSET, W - INSET * 2, H - INSET * 2);

  for (const b of bricks) {
    if (!b.alive) continue;
    ctx.strokeRect(b.x, b.y, b.w, b.h);
  }

  drawEffects();

  ctx.strokeRect(paddle.x, paddle.y, paddle.w, paddle.h);

  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.stroke();
}

function update(dt) {
  tickEffects(dt);

  const dir = (left ? -1 : 0) + (right ? 1 : 0);
  if (dir) lastServeDir = dir;

  const targetV = dir * paddle.speed;
  paddle.vx += (targetV - paddle.vx) * Math.min(1, dt * 18);

  if (!pointerDown) {
    paddle.x += paddle.vx * dt;
    paddle.x = clamp(paddle.x, INSET, W - INSET - paddle.w);
  }

  if (paused) {
    if (ball.stuck) {
      ball.x = paddle.x + paddle.w / 2;
      ball.y = paddle.y - ball.r - 2;
    }
    return;
  }

  if (ball.stuck) {
    ball.x = paddle.x + paddle.w / 2;
    ball.y = paddle.y - ball.r - 2;
    return;
  }

  moveBall(dt);

  if (ball.y - ball.r > H) {
    loseLife();
    return;
  }

  if (aliveBricks() === 0) {
    nextLevel();
  }
}

// init
setPaddleForLevel();
makeBricks();
setHUD();
resetBall(TEXT.overlay.start);

// fixed timestep
let last = performance.now();
let acc = 0;
const STEP = 1 / 120;

function loop(t) {
  const frameDt = Math.min(0.05, (t - last) / 1000);
  last = t;
  acc += frameDt;

  while (acc >= STEP) {
    update(STEP);
    acc -= STEP;
  }

  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
